{
  "title": "16 errors, 1 fail, 36 pass in 1h 23m 0s",
  "summary": "190 files  190 suites   1h 23m 0s ⏱️\n 53 tests  36 ✅ 0 💤 1 ❌ 16 🔥\n391 runs  324 ✅ 0 💤 1 ❌ 66 🔥\n\nResults for commit 7575fa0c.\n",
  "conclusion": "failure",
  "stats": {
    "files": 190,
    "errors": [],
    "suites": 190,
    "duration": 4980,
    "suite_details": [
      {
        "name": "validation_wokwi_esp32p4_i2c_master0",
        "tests": 5,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_uart0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c6_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_uart0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_i2c_master0",
        "tests": 5,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_i2c_master0",
        "tests": 5,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_i2c_master0",
        "tests": 5,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_unity0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c3_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_psram0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_i2c_master0",
        "tests": 5,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_uart0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_unity0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_psram0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_unity0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c3_timer0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32p4_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_timer0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_wifi2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32p4_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_psram0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_timer0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_touch0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_unity0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c6_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 1,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32h2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_uart0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_timer0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_i2c_master0",
        "tests": 5,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32h2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_touch0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_touch0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c6_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_i2c_master0",
        "tests": 5,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32h2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      }
    ],
    "tests": 53,
    "tests_succ": 36,
    "tests_skip": 0,
    "tests_fail": 1,
    "tests_error": 16,
    "runs": 391,
    "runs_succ": 324,
    "runs_skip": 0,
    "runs_fail": 1,
    "runs_error": 66,
    "commit": "7575fa0ce8fc8eb3cf886fe28ef1bd881cbbe01d"
  },
  "annotations": [
    {
      "path": "validation.nvs.test_nvs",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/nvs/esp32/nvs0.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32/nvs1.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32c3/nvs0.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32c3/nvs1.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32s2/nvs0.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32s2/nvs1.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32s3/nvs0.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32s3/nvs1.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/nvs/esp32s3/nvs2.xml [took 20s]",
      "title": "9 out of 42 runs with error: test_nvs (validation.nvs.test_nvs)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fac570e20>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fac273e80>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fac197c70>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7face41f00>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fac573760>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fac273e80>\ntarget = 'esp32s2', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_03-02-00-534114/test_nvs', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.periman.test_periman",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/periman/esp32/periman.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/periman/esp32c3/periman.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/periman/esp32s2/periman.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/periman/esp32s3/periman.xml [took 20s]",
      "title": "4 out of 6 runs with error: test_periman (validation.periman.test_periman)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f96fcf280>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f96ccffd0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f96bf7be0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f97899de0>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f96fcf790>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f96ccffd0>\ntarget = 'esp32s3', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_03-09-33-453700/test_periman', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "performance.coremark.test_coremark",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/performance/coremark/esp32/coremark.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/coremark/esp32c3/coremark.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/coremark/esp32s2/coremark.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/coremark/esp32s3/coremark.xml [took 20s]",
      "title": "4 out of 7 runs with error: test_coremark (performance.coremark.test_coremark)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f8ae657e0>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f8ab244f0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f8aa8fb50>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f8b731d80>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f8ae67400>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f8ab244f0>\ntarget = 'esp32', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-33-38-621805/test_coremark', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "performance.ramspeed.test_ramspeed",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/performance/ramspeed/esp32/ramspeed.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/ramspeed/esp32c3/ramspeed.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/ramspeed/esp32s2/ramspeed.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/ramspeed/esp32s3/ramspeed.xml [took 20s]",
      "title": "4 out of 7 runs with error: test_ramspeed (performance.ramspeed.test_ramspeed)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f93cd4e50>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f93994400>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f938ffb50>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f9459db10>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f93cd73a0>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f93994400>\ntarget = 'esp32', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-39-02-509255/test_ramspeed', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "performance.linpack_double.test_linpack_double",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/performance/linpack_double/esp32/linpack_double.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/linpack_double/esp32c3/linpack_double.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/linpack_double/esp32s2/linpack_double.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/linpack_double/esp32s3/linpack_double.xml [took 20s]",
      "title": "4 out of 7 runs with error: test_linpack_double (performance.linpack_double.test_linpack_double)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f83338e50>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f82ff8400>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f82f7c160>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f83c09b10>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f8333b3a0>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f82ff8400>\ntarget = 'esp32', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-35-48-200594/test_linpack_double', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.uart.test_uart",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/uart/esp32/uart.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/uart/esp32c3/uart.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/uart/esp32s2/uart.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/uart/esp32s3/uart.xml [took 20s]",
      "title": "All 4 runs with error: test_uart (validation.uart.test_uart)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f98d24e20>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f98a27df0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f9894bc70>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f995f5f00>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f98d27760>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f98a27df0>\ntarget = 'esp32s3', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_03-13-52-245599/test_uart', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "/home/runner/work/arduino-esp32/arduino-esp32/tests/validation/uart/uart.ino",
      "start_line": 78,
      "end_line": 78,
      "annotation_level": "warning",
      "message": "./artifacts/parent-artifacts/results/hw/validation/uart/esp32p4/uart.xml",
      "title": "1 out of 10 runs failed: change_pins_test",
      "raw_details": "Expected 'Hello from Serial1 using new pins' Was '\\xFFHello from Serial1 using new pins'"
    },
    {
      "path": "performance.fibonacci.test_fibonacci",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/performance/fibonacci/esp32/fibonacci.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/fibonacci/esp32c3/fibonacci.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/fibonacci/esp32s2/fibonacci.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/fibonacci/esp32s3/fibonacci.xml [took 20s]",
      "title": "4 out of 7 runs with error: test_fibonacci (performance.fibonacci.test_fibonacci)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f99080e50>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f98d44400>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f98cabe20>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f9992db10>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f990833a0>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f98d44400>\ntarget = 'esp32s2', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-42-22-915255/test_fibonacci', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.democfg.test_democfg",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/democfg/esp32/democfg0.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/democfg/esp32/democfg1.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/democfg/esp32s2/democfg.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/democfg/esp32s3/democfg.xml [took 20s]",
      "title": "4 out of 5 runs with error: test_cfg (validation.democfg.test_democfg)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fb5bef190>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fb58eff10>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fb5817be0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7fb64b5810>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fb5bef850>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fb58eff10>\ntarget = 'esp32', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-51-05-679610/test_cfg', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.hello_world.test_hello_world",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/hello_world/esp32/hello_world.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/hello_world/esp32c3/hello_world.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/hello_world/esp32s2/hello_world.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/hello_world/esp32s3/hello_world.xml [took 20s]",
      "title": "4 out of 14 runs with error: test_hello_world (validation.hello_world.test_hello_world)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f9881f190>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f9851fdf0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f984601f0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f990ed810>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f9881f850>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f9851fdf0>\ntarget = 'esp32s2', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-59-50-986769/test_hello_world', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "performance.psramspeed.test_psramspeed",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/performance/psramspeed/esp32/psramspeed.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/psramspeed/esp32s2/psramspeed.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/psramspeed/esp32s3/psramspeed.xml [took 20s]",
      "title": "3 out of 4 runs with error: test_psramspeed (performance.psramspeed.test_psramspeed)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7f8b0eb910>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7f8ada84c0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f8ad30280>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7f8b9b64d0>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7f8b0eb370>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7f8ada84c0>\ntarget = 'esp32', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-37-57-739615/test_psramspeed', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.unity.test_unity",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/unity/esp32/unity.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/unity/esp32c3/unity.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/unity/esp32s2/unity.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/unity/esp32s3/unity.xml [took 20s]",
      "title": "All 4 runs with error: test_unity (validation.unity.test_unity)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fa107f190>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fa0d7fee0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fa0ca7c70>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7fa1949810>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fa107f850>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fa0d7fee0>\ntarget = 'esp32s3', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_03-14-56-758713/test_unity', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "performance.superpi.test_superpi",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/performance/superpi/esp32/superpi.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/superpi/esp32c3/superpi.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/superpi/esp32s2/superpi.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/superpi/esp32s3/superpi.xml [took 20s]",
      "title": "4 out of 7 runs with error: test_superpi (performance.superpi.test_superpi)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fa4fad7e0>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fa4c6c4f0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fa4bd3b50>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7fa587dd80>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fa4faf400>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fa4c6c4f0>\ntarget = 'esp32s3', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-56-29-537806/test_superpi', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.psram.test_psram",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/psram/esp32/psram.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/psram/esp32s2/psram.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/psram/esp32s3/psram.xml [took 20s]",
      "title": "All 3 runs with error: test_psram (validation.psram.test_psram)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fa28ab280>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fa25abe50>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fa24d3c70>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7fa3171de0>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fa28ab790>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fa25abe50>\ntarget = 'esp32s2', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_03-04-10-048561/test_psram', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "performance.linpack_float.test_linpack_float",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/performance/linpack_float/esp32/linpack_float.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/linpack_float/esp32c3/linpack_float.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/linpack_float/esp32s2/linpack_float.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/performance/linpack_float/esp32s3/linpack_float.xml [took 20s]",
      "title": "4 out of 7 runs with error: test_linpack_float (performance.linpack_float.test_linpack_float)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fb64d7910>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fb61944c0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fb6118160>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7fb6da64d0>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fb64d7370>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fb61944c0>\ntarget = 'esp32s2', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-44-32-454003/test_linpack_float', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.timer.test_timer",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/timer/esp32/timer.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/timer/esp32c3/timer.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/timer/esp32s2/timer.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/timer/esp32s3/timer.xml [took 20s]",
      "title": "All 4 runs with error: test_timer (validation.timer.test_timer)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fa2dd3190>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fa2ad3f70>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fa29fbc70>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7fa3699810>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fa2dd3850>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fa2ad3f70>\ntarget = 'esp32c3', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_02-46-39-196330/test_timer', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": "validation.touch.test_touch",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/parent-artifacts/results/hw/validation/touch/esp32/touch.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/touch/esp32s2/touch.xml [took 20s]\n./artifacts/parent-artifacts/results/hw/validation/touch/esp32s3/touch.xml [took 20s]",
      "title": "All 3 runs with error: test_touch (validation.touch.test_touch)",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...arduino.app.ArduinoApp object at 0x7fa93df2e0>, 'msg_queue': <pytest_embedded.log.MessageQueue object at 0x7fa909c580>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fa9007c70>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, (subprocess.Popen, multiprocessing.process.BaseProcess)):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/site-packages/pytest_embedded/plugin.py:1120: in serial\n    return serial_gn(**locals())\n/usr/local/lib/python3.10/site-packages/pytest_embedded/dut_factory.py:466: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n/usr/local/lib/python3.10/site-packages/pytest_embedded_arduino/serial.py:26: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x7fa9ca9f30>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x7fa93df970>\nmsg_queue = <pytest_embedded.log.MessageQueue object at 0x7fa909c580>\ntarget = 'esp32s2', beta_target = None, port = None, port_mac = None\nbaud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2025-03-02_03-06-19-319082/test_touch', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}\navailable_ports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\nports = ['/dev/ttyUSB0', '/dev/ttyUSB1', '/dev/ttyUSB2', '/dev/ttyUSB3']\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: Optional[str] = None,\n        beta_target: Optional[str] = None,\n        port: Optional[str] = None,\n        port_mac: Optional[str] = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Optional[Meta] = None,\n        ports_to_occupy: List[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list() if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.10/site-packages/pytest_embedded_serial_esp/serial.py:118: ValueError"
    },
    {
      "path": ".github",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "notice",
      "message": "There are 53 tests, see \"Raw output\" for the full list of tests.",
      "title": "53 tests found",
      "raw_details": "auto_baudrate_test\nbasic_transmission_test\nbegin_when_running_test\nchange_baudrate_test\nchange_clock\nchange_cpu_frequency_test\nchange_pins_test\ndisabled_uart_calls_test\nenabled_uart_calls_test\nend_when_stopped_test\nperformance.coremark.test_coremark ‑ test_coremark\nperformance.fibonacci.test_fibonacci ‑ test_fibonacci\nperformance.linpack_double.test_linpack_double ‑ test_linpack_double\nperformance.linpack_float.test_linpack_float ‑ test_linpack_float\nperformance.psramspeed.test_psramspeed ‑ test_psramspeed\nperformance.ramspeed.test_ramspeed ‑ test_ramspeed\nperformance.superpi.test_superpi ‑ test_superpi\nperiman_test\npsram_found\nresize_buffers_test\nrtc_run_clock\nrtc_set_time\nswap_pins\ntest_api\ntest_calloc_success\ntest_fail\ntest_malloc_fail\ntest_malloc_success\ntest_memcpy\ntest_memset_all_ones\ntest_memset_all_zeroes\ntest_memset_alternating\ntest_memset_random\ntest_pass\ntest_realloc_success\ntest_touch_errors\ntest_touch_interrtupt\ntest_touch_read\ntimer_clock_select_test\ntimer_divider_test\ntimer_interrupt_test\ntimer_read_test\nvalidation.democfg.test_democfg ‑ test_cfg\nvalidation.gpio.test_gpio ‑ test_gpio\nvalidation.hello_world.test_hello_world ‑ test_hello_world\nvalidation.nvs.test_nvs ‑ test_nvs\nvalidation.periman.test_periman ‑ test_periman\nvalidation.psram.test_psram ‑ test_psram\nvalidation.timer.test_timer ‑ test_timer\nvalidation.touch.test_touch ‑ test_touch\nvalidation.uart.test_uart ‑ test_uart\nvalidation.unity.test_unity ‑ test_unity\nvalidation.wifi.test_wifi ‑ test_wifi"
    }
  ],
  "check_url": "https://github.com/espressif/arduino-esp32/runs/38049531636",
  "formatted": {
    "stats": {
      "files": "190",
      "errors": [],
      "suites": "190",
      "duration": "4 980",
      "suite_details": [
        {
          "name": "validation_wokwi_esp32p4_i2c_master0",
          "tests": 5,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_uart0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c6_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_uart0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_i2c_master0",
          "tests": 5,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_i2c_master0",
          "tests": 5,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_i2c_master0",
          "tests": 5,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_unity0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c3_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_psram0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_i2c_master0",
          "tests": 5,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_uart0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_unity0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_psram0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_unity0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c3_timer0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32p4_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_timer0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_wifi2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32p4_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_psram0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_timer0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_touch0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_unity0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c6_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 1,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32h2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_uart0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_timer0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_i2c_master0",
          "tests": 5,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32h2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_touch0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_touch0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c6_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_i2c_master0",
          "tests": 5,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32h2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        }
      ],
      "tests": "53",
      "tests_succ": "36",
      "tests_skip": "0",
      "tests_fail": "1",
      "tests_error": "16",
      "runs": "391",
      "runs_succ": "324",
      "runs_skip": "0",
      "runs_fail": "1",
      "runs_error": "66",
      "commit": "7575fa0ce8fc8eb3cf886fe28ef1bd881cbbe01d"
    }
  }
}